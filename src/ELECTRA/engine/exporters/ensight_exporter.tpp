/*
 * ELECTRA. Electrophysiology Simulation Software.
 * Copyright (C) 2019  <Konstantinos A. Mountris> <konstantinos.mountris@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */


#ifndef ELECTRA_EXPORTERS_ENSIGHT_EXPORTER_TPP_
#define ELECTRA_EXPORTERS_ENSIGHT_EXPORTER_TPP_


#include "ELECTRA/engine/exporters/ensight_exporter.hpp"


namespace ELECTRA {

template<short DIM, short CELL_NODES>
EnsightExporter<DIM, CELL_NODES>::EnsightExporter()
{}


template<short DIM, short CELL_NODES>
EnsightExporter<DIM, CELL_NODES>::~EnsightExporter()
{}


template<short DIM, short CELL_NODES>
void EnsightExporter<DIM, CELL_NODES>::SaveGeo(const std::vector<IMP::Vec<DIM, double>> &nodes, const std::vector<IMP::Cell<DIM, CELL_NODES>> &cells, const std::string &out_filename)
{
    namespace boost_fs = boost::filesystem;

    // Position of the last slash in the exporting file's name.
    std::size_t last_slash = out_filename.find_last_of("/\\");

    // Get the path directory of the exporting file name.
    std::string path = "";
    if (last_slash != std::string::npos) { path = out_filename.substr(0, last_slash); }

    // Create the path's directory if it doesn't exist.
    boost_fs::path dir(path);
    if (!path.empty() && !boost_fs::exists(dir)) { boost_fs::create_directories(dir); }

    // Search for the extension of the output geometry file.
    std::string ext = "";
    if (out_filename.find_last_of(".") != std::string::npos) {
        ext = out_filename.substr(out_filename.find_last_of("."));
    }

    // Open output geometry file.
    std::ofstream geo_out;
    if (ext == ".geo") {
        geo_out.open(out_filename, std::ofstream::out | std::ofstream::trunc);
    } else {
        geo_out.open(out_filename+".geo", std::ofstream::out | std::ofstream::trunc);
    }

    // Check if file was properly opened.
    if (!geo_out.is_open()) {
        throw std::invalid_argument(Logger::Error("Could not create Ensight geometry file. Check file path: "+out_filename));
    }

    // Write header.
    geo_out << "Ensight model geometry file generated by ELECTRA-console v" << ELECTRA_VERSION << "\n";
    geo_out << "For information about ELECTRA-console, contact: konstantinos.mountris@gmail.com\n";
    geo_out << "node id off\nelement id off\n";
    geo_out << "part\n1\n";
    geo_out << "Model, Geometry 1\n";
    
    // Write nodes coordinates.
    geo_out << "coordinates\n" << nodes.size() << "\n";
    for (short d = 0; d != DIM; ++d) {
        for (std::size_t id = 0; id != nodes.size(); ++id)
            geo_out << nodes[id][d] << "\n";
    }
    // Fill missing coordinate dimensions wit zeros for problems with less than 3 dimensions.
    if (DIM < 3) {
        for (std::size_t id = 0; id != (3-DIM)*nodes.size(); ++id)
            geo_out << "0.0\n";
    }

    // Create a flag for each connected node of the grid.
    Eigen::SparseVector<int> conn_node_ids(nodes.size());

    // Write cells connectivity.
    if (DIM == 1 && CELL_NODES == 2) { geo_out << "bar2\n"; }
    else if (DIM == 2 && CELL_NODES == 2) { geo_out << "bar2\n"; }
    else if (DIM == 2 && CELL_NODES == 3) { geo_out << "tria3\n"; }
    else if (DIM == 2 && CELL_NODES == 4) { geo_out << "quad4\n"; }
    else if (DIM == 3 && CELL_NODES == 2) { geo_out << "bar2\n"; }
    else if (DIM == 3 && CELL_NODES == 3) { geo_out << "tria3\n"; }
    else if (DIM == 3 && CELL_NODES == 4) { geo_out << "tetra4\n"; }
    else if (DIM == 3 && CELL_NODES == 8) { geo_out << "hexa8\n"; }
    else {
        std::string error_msg = "Could not create Ensight geometry file due to not supported elements with Dimensions: " + 
                                std::to_string(DIM) + " and Nodes: " + std::to_string(CELL_NODES);
        throw std::runtime_error(Logger::Error(error_msg));
    }

    // Output cells of connected nodes.
    geo_out << cells.size() << "\n"; 
    for (const auto &cell : cells) {
        for (short nid = 0; nid != CELL_NODES-1; ++nid) {
            geo_out << cell.N(nid)+1 << " ";
            conn_node_ids.coeffRef(cell.N(nid)) = 1;
        }
        geo_out << cell.N(CELL_NODES-1)+1 << "\n";
        conn_node_ids.coeffRef(cell.N(CELL_NODES-1)) = 1;
    }

    // Output 0D cells of not connected nodes.
    if (conn_node_ids.nonZeros() < static_cast<int>(nodes.size())) {
        geo_out << "point\n";
        geo_out << static_cast<int>(nodes.size()) - conn_node_ids.nonZeros() << "\n";
        for (int i = 0; i != conn_node_ids.rows(); ++i) {
            if (conn_node_ids.coeff(i) == 0)
                geo_out << i+1 << "\n";
        }
    }

    // Close the geometry output file.
    geo_out.close();

}


template<short DIM, short CELL_NODES>
void EnsightExporter<DIM, CELL_NODES>::SaveScalarField(const Eigen::VectorXd &scalar_field, const std::string &out_filename)
{
    namespace boost_fs = boost::filesystem;
    boost_fs::path p(out_filename);
    std::string path = p.parent_path().string();

    // Create the path's directory if it doesn't exist.
    boost_fs::path dir(path);
    if (!path.empty() && !boost_fs::exists(dir)) { boost_fs::create_directories(dir); }

    // Search for the extension of the output geometry file.
    std::string ext = "";
    if (out_filename.find_last_of(".") != std::string::npos) {
        ext = out_filename.substr(out_filename.find_last_of("."));
    }

    // Open output geometry file.
    std::ofstream scalar_out;
    if (ext == ".ens") {
        scalar_out.open(out_filename, std::ofstream::out | std::ofstream::trunc);
    } else {
        scalar_out.open(out_filename+".ens", std::ofstream::out | std::ofstream::trunc);
    }

    // Check if file was properly opened.
    if (!scalar_out.is_open()) {
        throw std::invalid_argument(Logger::Error("Could not create Ensight scalar field file. Check file path: "+out_filename));
    }
    
    // Write header file.
    scalar_out << "Ensight Model Post Process\npart\n  1\ncoordinates\n";

    // Write scalar field.
    for (int i = 0; i != scalar_field.size(); ++i) {
        scalar_out << scalar_field.coeff(i) << "\n";
    }

    // Close file.
    scalar_out.close();

}


template<short DIM, short CELL_NODES>
void EnsightExporter<DIM, CELL_NODES>::SaveAnimation(const std::string &out_filename, const std::string &geo_filename, const std::string &state_filename, 
                                                     const std::vector<std::string> &scalar_field_files, const std::vector<std::string> &scalar_field_names, int steps_num, double time_inc)
{
    namespace boost_fs = boost::filesystem;

    // Get the path directory of the exporting animation file.
    boost_fs::path anim_p(out_filename);
    std::string anim_path = anim_p.parent_path().string();

    // Get the path directory of the geometry file.
    boost_fs::path geo_p(geo_filename);
    std::string geo_path = geo_p.parent_path().string();

    // Get the path directory of the scalar state files.
    boost_fs::path scalar_p(state_filename);
    std::string scalar_path = scalar_p.parent_path().string();

    // Check paths consistency.
    if (anim_path != geo_path || anim_path != scalar_path) {
        std::cout << anim_path << "\n" << geo_path << "\n" << scalar_path << "\n";
        std::string error_str = "Could not save Ensight animation file. Check that both geometry and states filepaths are the same with the animation filepath.";
        throw std::invalid_argument(Logger::Error(error_str));
    }

    // Create the path's directory if it doesn't exist.
    boost_fs::path dir(anim_path);
    if (!anim_path.empty() && !boost_fs::exists(dir)) { boost_fs::create_directories(dir); }

    // Search for the extension of the output geometry file.
    std::string ext = anim_p.extension().string();

    // Open output geometry file.
    std::ofstream case_out;
    if (ext == ".case") {
        case_out.open(out_filename, std::ofstream::out | std::ofstream::trunc);
    } else {
        case_out.open(out_filename+".case", std::ofstream::out | std::ofstream::trunc);
    }

    // Isolate the name of the scalar solution without any numbers.
    std::string scalar_name = scalar_p.filename().string();
    scalar_name = scalar_name.substr(0, scalar_name.find_first_of("0123456789"));

    // Set number of wildcard symbols for steps.
    std::size_t wildcard_num = std::to_string(steps_num).size();
    std::string asterisks(wildcard_num, '*');

    // Write header.
    case_out << "# Ensight format output generated by: ELECTRA-console v.Â·" << ELECTRA_VERSION << "\n";
    case_out << "# For information about ELECTRA-console, contact: konstantinos.mountris@gmail.com\n\n";
    
    case_out << "FORMAT\ntype: ensight gold\n\n";

    case_out << "GEOMETRY\n";
    case_out << "model: " << geo_p.filename().string() << "\n\n";
    
    case_out << "VARIABLE\n";    
    case_out << "scalar per node: Potential " << scalar_name + asterisks + ".ens" << "\n";

    for (std::size_t i = 0; i != scalar_field_files.size(); ++i) {
        boost_fs::path scal_field_path(scalar_field_files[i]);
        case_out << "scalar per node: " << scalar_field_names[i] << " " << scal_field_path.filename().string() << "\n";
    }
    case_out << "\n";
    
    case_out << "TIME\n";
    case_out << "time set: " << time_inc << "\n";
    case_out << "number of steps: " << steps_num << "\n";
    case_out << "filename start number: 0\n";
    case_out << "filename increment: 1\n";
    case_out << "time values: ";

    // Write time increments
    int skip = 0;
    for (int i = 0; i != steps_num; ++i) {
        case_out << i*time_inc << " ";
        skip++;

        if (skip == 30) {
            case_out << "\n             ";
            skip = 0;
        }
    }


    // Close file
    case_out.close();

}


} //end of namespace ELECTRA


#endif // ELECTRA_EXPORTERS_ENSIGHT_EXPORTER_TPP_